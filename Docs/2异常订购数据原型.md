```Java
UserInfo{
    //用户id
    long msisdn;
    //最新一次更新数据的时间。
    long lastUpdateTime;

    //一下数据结构中 Long 为插入数据的时间。所以要定义一个Pair<String, Long>的数据结构，放在Queue中。
    //用户的session信息。
    //应用在规则 8
    Queue<String, Long> sessionInfo ;

    //用户Ip信息
    //应用在规则 9
    Queue<String, Long> ipInfo ;

    //终端信息。
    //应用在规则 10
    Queue<String, Long> terminalInfo ;

    ps: 上述seesionInfo ipInfo terminaInfo 公用间隔为1 小时的定时器。
    sessionInfo ipInfo terminaInfo 插入的时候要和队尾的只进行比较，如果不同才插入。

    	由于用户可以更换的终端，ip和session 数量有限。所以不采用比较复杂的双桶结构。

    public void insertToSessionInfoQueue();
    public void insertToIpInfoQueue();
    public void insertToTerminalInfoQueue();

    private void insertToQueue(Type);

    每次插入的时候首先和上一次进行比较，
    	如果相同，则返回。
    	如果不同，则插入队列末尾。并清除当前时间一小时以外的数据。统计Queue的长度。和规则进行比对。

    定时器：
    	public void clearAndUpdateTimer();
    功能；
    	每一个小时统计检查lastUpdateTime。如果超过一小时。说明内部所有数据超时。则清除该User
}


Session{
    //本次访问的sessionId
    long sessionId ;
    //本sessionId 相对应的用户id
    long msisdn ;
    //如果为订购页面，此字段为本次订购的应收信息费
    int realInfoFee ;
    //渠道代码
    int channelId ;

    //最新一次更新数据的时间。
    long lastUpdateTime ;

    //Map存储为BookId 和 ClickTime 的Queue。定时器每个小时进行一次清空。
    //应用在规则1、2、5
    Map<String, Queue<Long>> lastHourBookReadpv ;
    Map<String, Queue<Long>> currentHourBookReadpv ;

    //Map存储为BookId 和 订购时间 的Queue。 定时器每5分钟进行一次清空。
    //应用在规则6
    规则 6 说明：
    	if( bookOrderTime.get(BookId).getSize()>=2 && currentHourBookReadpv 中5分钟的pv数 <= 5 * 前面的订购次数==>bookOrderTime.get(BookId).getSize() ))
    Map<String, Queue<Long>> bookOrderTime ;

    //Map存储为Map<BookId, Map<chapterId, Queue<orderTime>> 定时器为5分钟。
    //应用在规则7
    规则 7 说明：
    	if( boookChapterOrderTime.get(BookId).getSize() >=2 && currentHourBookReadpv 中5分钟的pv数 <= 5 * 前面的订购次数==>bookOrderTime.get(BookId).getSize() )
    Map<String, Map<String, Queue<Long>>> boookChapterOrderTime ;

    定时器；
    	public void clearAndUpdateTimer();
    解决问题：
    	节约内存。清除过期session
    功能：
    	lastHourBookReadpv currentHourBookReadpv 为65分钟清除一次。
    	bookOrderTime boookChapterOrderTime 为 分钟清除一次。
}
```

```
* 关于"双桶"结构的说明： 以lastHourBookReadpv 和 currentHourBookReadpv 为例：
    lastHourBookReadpv 前一个时间段图书的浏览pv 例如当前时间为8.44分。此Map存储的为7-8点的图书点击pv
    currentHourBookReadpv 存储当前时间段的图书浏览pv。 此map存储8-现在的 图书点击pv
 ** 接收消息
    浏览消息：
 	    接受收到新的浏览消息，先从lastHourBookReadPv中根据BookId找到对应的Queue。
	若找到，1. 根据当前时间，出队所有过期pv。2. 将当前记录插入到队尾。 3. 将此条记录从		lastHourBookReadpv中移除，插入到currentBookReadpv中。若没有找到， 1. 直接插入到currentBookReadpv 中。
     订购消息:
         收到定时器消息，直接启动一个5分钟的计时器来判定是否合法。
	     定时器时间到达后，需要做的事情是检查currentHourBookPv中的数据某BookId下的ReadPv个数。进而判断是否合法。
 ** 定时器：
		定时器设定为每隔65分钟启动一次。定时器所作的任务有：首先将lastHourBookReadpv = null, 将currentBookReadpv中的数据移动到 lastHourBookReadpv中。 currentHourBookReadpv.clear()。
		若此时currentBookReadpv.size() == 0 && bookOrderTime.size() ==0 && boookChapterOrderTime.size() == 0。 则可以清除本条Session记录。

```
































